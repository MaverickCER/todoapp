import fs from 'fs';
import path from 'path';
import sharp from 'sharp';
import { fileURLToPath } from 'url';

// Get the current directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const iconsDir = path.resolve(__dirname, '../src/assets/icons');
const iconsIndexFile = path.resolve(__dirname, '../src/assets/icons/index.ts');
const imagesDir = path.resolve(__dirname, '../src/assets/images');
const imagesIndexFile = path.resolve(__dirname, '../src/assets/images/index.tsx');

// Utility function to convert file name to PascalCase
const toPascalCase = (fileName) => {
  return fileName
    .replace(/\.svg$/, '')
    .replace(/[^a-zA-Z0-9]/g, ' ')
    .split(/\s+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(''); // Join words together
};

// Function to get all icon files in the directory
const getIconFiles = (dir) => {
  const files = fs.readdirSync(dir);
  const validFiles = [];

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const fileSize = fs.statSync(filePath).size;

    if (path.extname(file).toLowerCase() === '.svg') {
      if (fileSize > 2048) {
        console.error(`Critical: File ${file} is over 2KB in size. Make sure you don't have nested base64 data`);
      } else if (fileSize > 1024) {
        console.warn(`Error: File ${file} is over 1kb in size. Optimization required!`);
      } else if (fileSize > 512) {
        console.info(`Warning: File ${file} is over 512MB in size.`);
      }

      validFiles.push(file); // Always add the file to the list, regardless of size
    }
  });

  return validFiles;
};

// Function to generate the TypeScript export statements
const generateIconsIndexFile = (files) => {
  // Generate import statements
  return files
    .map((file) => {
      const iconName = toPascalCase(file);
      return `export { default as ${iconName} } from "./${file}?react";`;
    })
    .join('\n');
};

// Function to get all image files in the directory
const getImageFiles = (dir) => {
  const files = fs.readdirSync(dir);
  const validFiles = [];

  files.forEach((file) => {
    const ext = path.extname(file).toLowerCase();
    if (['.ts', '.js', '.tsx', '.jsx', '.md'].includes(ext)) return;
    validFiles.push(file);
  });

  return validFiles;
};

// Function to rename a file to PascalCase
const renameToPascalCase = (filePath) => {
  const ext = path.extname(filePath);
  const fileNameWithoutExt = path.basename(filePath, ext);
  const pascalCaseName = toPascalCase(fileNameWithoutExt) + ext;
  const newFilePath = path.join(path.dirname(filePath), pascalCaseName);

  // Rename the file if the PascalCase version doesn't exist
  if (filePath !== newFilePath && !fs.existsSync(newFilePath)) {
    fs.renameSync(filePath, newFilePath);
    console.log(`Renamed ${filePath} to ${newFilePath}`);
  }

  return newFilePath;
};

// Function to convert an image to WebP if it's not already WebP
const convertToWebP = async (filePath) => {
  const ext = path.extname(filePath).toLowerCase();

  // Skip if it's already a WebP
  if (ext === '.webp') return filePath;

  const newFilePath = filePath.replace(ext, '.webp');

  try {
    await sharp(filePath).toFormat('webp', { quality: 100 }).toFile(newFilePath);

    // Delete the original file
    fs.unlinkSync(filePath);

    console.log(`Converted ${filePath} to WebP and saved as ${newFilePath}`);
    return newFilePath;
  } catch (error) {
    console.error(`Error converting ${filePath} to WebP:`, error);
    return filePath; // Fallback in case of error
  }
};

// Function to generate the TypeScript export statements
const generateImageIndexFile = (files) => {
  const imports = [`import Image from 'next/image';`];
  const exports = [];
  for (const file of files) {
    const fileNameWithoutExt = path.basename(file, '.webp');
    imports.push(`import ${fileNameWithoutExt}Image from './${fileNameWithoutExt}.webp';`);
    exports.push(
      `export const ${fileNameWithoutExt} = (props) => <Image src={${fileNameWithoutExt}Image} aria-hidden="true" alt="${fileNameWithoutExt}" {...props} />`,
    );
  }

  const imagesIndexContent =
    `// NOTICE: This file is automatically generated with npm run sync! Do not modify\n` +
    `${imports.join('\n')}\n\n${exports.join('\n')}\n`;

  // Write the index.ts file
  fs.writeFileSync(imagesIndexFile, imagesIndexContent, 'utf8');
  console.log(`Icons index file generated successfully at ${imagesIndexFile}`);
};

// Main function
const main = async () => {
  try {
    const iconFiles = getIconFiles(iconsDir);
    const iconsIndexContent = generateIconsIndexFile(iconFiles);
    fs.writeFileSync(iconsIndexFile, iconsIndexContent, 'utf8');
    console.log(`Icons index file generated successfully at ${iconsIndexFile}`);
    const imageFiles = getImageFiles(imagesDir);
    const convertedFilesSet = new Set(); // Use a Set to store unique file paths

    // Convert images to PascalCase, then to WebP if not already WebP
    for (const file of imageFiles) {
      let fullPath = path.join(imagesDir, file);

      // Rename file to PascalCase
      fullPath = renameToPascalCase(fullPath);

      // Convert image to WebP
      const webPPath = await convertToWebP(fullPath);
      convertedFilesSet.add(webPPath);
    }

    // Generate imagesIndex.ts file
    const convertedFiles = Array.from(convertedFilesSet); // Convert Set to Array
    generateImageIndexFile(convertedFiles);
  } catch (error) {
    console.error('Error generating iconsIndex file:', error);
  }
};

// Run the script
main();
